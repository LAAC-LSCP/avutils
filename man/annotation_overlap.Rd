% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/annotation_overlap.R
\name{annotation_overlap}
\alias{annotation_overlap}
\title{calculate overlap between two binary annotation sets}
\usage{
annotation_overlap(x1, x2, seg_length = NULL, overlap_res = 100,
  return_raw = FALSE)
}
\arguments{
\item{x1}{data.frame or matrix with annotations, needs columns named \code{"start"} and \code{"end"}}

\item{x2}{data.frame or matrix with annotations, needs columns named \code{"start"} and \code{"end"}}

\item{seg_length}{numeric, total duration of the data (default is \code{NULL}, i.e. it's guessed from the data), see details}

\item{overlap_res}{numeric, resolution for overlap (default is \code{100}), see details}

\item{return_raw}{logical, by default \code{FALSE}, i.e. return the proportion. Otherwise return a 0/1 vector where 1 indicates a congruent comparison.}
}
\value{
a numeric value of overlap proportion
}
\description{
calculate overlap between two binary annotation sets
}
\details{
This function works like this. Given the total duration of an annotation file (e.g. 60 seconds), create a sequence of test values between 0 and the duration in steps determined by \code{overlap_res}. For example, if the resolution is 100 and the duration is 60 seconds, these values will be 0, 0.6, 1.2, 1.8 etc. (Technically, this corresponds to 100 + 1 values). Now, for each of these test values, check in \code{x1} and \code{x2} whether an annotation exists that comprises this value (or not). In our example this would lead to 100 \emph{pairs} of values (i.e. 100 comparisons). Each comparison can be either congruent (i.e. the test value is either covered in both \code{x1} and \code{x2}, or neither in \code{x1} and \code{x2}), or a comparison can be incongruent, i.e. it's covered in \code{x1} or \code{x2}. From this, we can calculate the proportion of comparisons that are congruent, which is the result of this function.

For now, the function returns \code{NA} if one of the two annotation sets contains no data. If both annotation sets are empty, the function will return \code{1}.
}
\examples{
x1 <- data.frame(start = c(1, 4, 7), end = c(2.3, 4.2, 8))
x2 <- data.frame(start = c(0, 5), end = c(4, 6))
annotation_overlap(x1, x2)
annotation_overlap(x1, x2, seg_length = 60)
# one annotation set is empty
x3 <- x2[0, ]
annotation_overlap(x1, x3)
}
